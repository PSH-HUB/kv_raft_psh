# 🗳️ Leader选举
--- 
## 🔧 选举流程核心模块
---
### 🎯 electiontimeoutticker 改造要点

- `usleep` → `sleep_for`
- `std::chrono::system_clock` → `std::chrono::steady_clock`
- `mtx` → `lock_guard`
- `std::chrono::_V2::system_clock::time_point` -> `std::chrono::steady_clock::time_point`
------  

## 🎁流程图：
+-----------------------------+
| while (true)               |
|    if (isLeader) sleep     |
|    calculate timeout       |
|    sleep(剩余时间)          |
|    if (超时期间收到心跳)     |
|        continue            |
|    else                    |
|        doElection()        |
+-----------------------------+
## 🎯目的：
Raft 协议中的每个节点都维护一个 选举超时定时器。 当 follower 或 candidate 节点在一段时间内未收到来自 leader 的心跳时，就会触发选举流程。
为了避免无意义的 CPU 空转和频繁选举，选举定时器必须设计得 合理、可控、可打断
---
- 🧠关键原理
- 心跳时间（HeartBeatTimeout） 要远小于选举超时时间（ElectionTimeout）一个数量级。
- 例如：心跳 100ms，选举超时为 [150ms ~ 300ms] 随机。
- 确保 follower 节点能及时收到 leader 的心跳，避免因延迟误判 leader 失联而发起选举。

- 定时器线程常驻运行，但不空转
- 在非 leader 状态下，线程会“睡眠”，等待随机超时时间过去。
- 为避免精度误差，睡眠时间 = 随机超时时间 + 上次重置时间 - 当前时间。
## 🚨 超时的本质说明
🚨🚨🚨🚨超时的本质不是时间到了  而是指没有人在这段时间这内联系我  这才叫超时🚨🚨🚨🚨
---
## 😴 睡眠与唤醒逻辑说明
- 防止空转所以要睡觉 有时间睡就会睡 没时间就说明该选举了 如果睡的时候没有人喊我那就说明超时了 有人喊我那就说明没有超时


----------------------------------------------------------------------------------------------------------------------------------

### 🎯 doElection 要点说明（未改造版本）

- 当前节点在选举定时器超时时发起选举，前提是当前不是 Leader。
- 切换自身状态为 Candidate，并自增当前任期（`m_currentTerm++`），同时投票给自己（`m_votedFor = m_me`）。
- 持久化关键状态（`term`、`votedFor`）以防崩溃恢复出错。
- 遍历集群中所有其他节点，通过异步线程方式调用 `sendRequestVote()`，向其发送投票请求。
- 每个投票请求封装当前节点的 term、candidateId、最后日志索引和任期等信息。
- 投票结果使用共享的计数器 `votedNum` 进行统计，如果获得多数票则切换为 Leader。

> 💡 **后续优化建议**：当前实现中为每个投票请求创建一个线程，这在节点数较多时会导致频繁的线程创建与销毁，带来系统开销。建议后续引入**线程池机制**进行统一调度和复用，提高系统稳定性与性能。

----------------------------------------------------------------------------------------------------------------------------------

### 🎯 sendRequestVote 要点说明（未改造版本）

- 通过 RPC 框架调用对方节点的 `RequestVote()` 接口，尝试获取投票支持。
- 首先判断 RPC 是否成功发送并收到响应，失败直接返回，防止挂起或异常情况（例如宕机）引发问题。
- 响应返回后，通过加锁保护状态一致性，并判断对方返回的 term 是否大于当前节点：
  - 如果对方的 term 更大，说明自己已经落后，立刻降为 Follower，并更新 term 与投票信息，执行持久化。
- 若投票成功（`voteGranted == true`），则原子性地递增投票数。
- 若票数超过集群总数的一半（`> N/2`），当前 Candidate 成为 Leader，初始化 `nextIndex[]` 与 `matchIndex[]`，并立即开始发送心跳（`doHeartBeat()`）维护领导权。

> 💡 **后续优化建议**：  
> - 当前为每个 `sendRequestVote` 调用创建单独线程，资源开销较大。建议引入线程池进行投票 RPC 管理。  
> - 对返回的 RPC 应答要保证健壮性校验，尤其是 term 变更相关逻辑的处理必须符合 Raft 协议严格定义。

-----------------------------------------------------------------------------------------------------------------------------------

### 🎯 `RequestVote` 要点说明（未改造版本）

- **RPC 调用**：通过 Raft 协议中的 `RequestVote()` 接口处理节点投票请求，主要用于响应候选者请求获取投票。
- **加锁保护**：首先进行加锁，保证线程安全，避免多个线程同时访问共享资源。
- **任期检查**：
  - 如果候选者的 `args->term()` 小于当前节点的 `m_currentTerm`，说明该候选者的任期已经过时，拒绝投票并返回。
  - 如果候选者的 `args->term()` 大于当前节点的 `m_currentTerm`，则更新当前节点的任期为候选者的任期，变为 Follower 状态，并清空投票信息。
- **日志一致性检查**：如果 `args->term()` 与当前节点的 `m_currentTerm` 相同，进一步检查候选者的日志一致性：
  - 如果候选者的日志任期小于当前节点的日志任期，或者候选者的日志索引小于当前节点的日志索引，拒绝投票。
  - 如果候选者的日志符合条件且节点尚未投票，则投票给该候选者，更新 `m_votedFor` 为候选者的 ID，并重置选举定时器。
- **投票结果返回**：返回投票结果，包含当前节点的任期、投票状态（如 `Expire`, `Voted`, `Normal`）和是否授予投票。

> 💡 **后续优化建议**：  
> - 目前每个 `sendRequestVote` 调用都会创建单独线程，资源开销较大，建议引入线程池管理投票 RPC。  
> - 对返回的 RPC 应答要进行严格的健壮性校验，特别是处理与 `term` 相关的逻辑时，必须遵循 Raft 协议的定义。

-----------------------------------------------------------------------------------------------------------------------------------

# 🗳️ 日志复制与心跳机制
---
## 🔧 核心模块
---
### 🎯 leaderheartbeatticker
- 类似于前面的选举超时 只不过前面是对于follower而言的 这个是对于leader而言的
- leader在发完一个心跳之后也会休眠一个合理时间，醒了之后会检查是否超时也就是是否重置了定时器 如果没有超时就继续睡眠即可
- 定时器重置说明在睡眠的时间里发送了心跳  所以心跳在这段时间之内是没有超时的所以继续睡眠

### 🎯 doheartbeat
- 这里主要就是发送心跳  然后心跳里面会附带着我们的日志或者快照消息
- 如果日志在快照之前就需要发快照来恢复  如果在快照之后就需要判断 可以从日志中补齐  也可以从快照位置补齐
- 然后封装请求和恢复  进行发送  并重置心跳定时器

### 🎯 sendappendentries 和 appendentries
- 这个类似于sendrequestvote和requestvote
- bool ok = 调用 RPC -> 有没有通？有没有返回？   bool reply->success() = 对方收到了请求 -> 能不能成功执行？业务是否成功？
- 这里注意一下request和append的区别
✅ 1. sendAppendEntries 是周期性、持续性的操作：

    每隔 heartbeatInterval，Leader 就会向所有 Follower 发送心跳（也就是空的 AppendEntries）；

    如果某个 Follower 状态是 Disconnected，可以暂时跳过它，等待下一次再发就行；

    Raft 的共识要求只是“超过半数响应”，所以某个 Follower 异常不影响整体可用性；

    这时候，Leader 不需要太强求所有节点都立即响应，避免被异常节点拖慢。
❌ 2. RequestVote 是一次性的“选举投票”，必须明确拿到 yes/no：

    投票 RPC 是临时发起的，目的是快速选出一个 Leader；

    Candidate 发起投票，需要收集到超过半数 voteGranted = true；

    如果 Follower 返回 Disconnected 或不返回，Candidate 就要等待超时或继续重试；

    不能“跳过”这个节点的反馈，否则可能导致选不出 Leader 或误选。

### 🎯 leadersendsnapshot和installsnapshot
- 日志远小于leader日志 无法通过日志补全 来发送快照快速恢复
- 调用rpc 然后封装请求和回复信息 

